CECS 343 8/27/2020

Chapter 1 -- What is Software Engineering?

-engineering approach to develop software.
    -building construction analogy.
    -we will never complete the project

-Systematic collection of past experience
    -techniques
    -methologies
    -guidelines

IEEE definition of what software engineering

Software engineering is the appliction of a systematic,
disciplines, quantifiable approach to the development,
operation and maintenance of software; that is, the
application of engineering to software.
    
It is often the case that software products

-Fail to meet user requirements
-expensive
-difficult to alter, debug, and enhance
-often delivered late
-use resources non-optimally

hardware cost has dropped significantly but now the software
is much more expensive. 

a virtue of software
-relatively easy and faster to develop and to change
-consumes no space, weight, or power
-otherwise all might as well be hardware

the more complex the software is the harder it is to change
-further the more changes made to a program, the more
complex it becomes

what factors are contributing to the software crisis?

-larger problems

-poor project management

-lack of adequate training in software engineering.

-what is wrong with the exploratory style
---can successfully be used for developing only small programs
---programs are unmaintainable
---unsuitable for team environments

----two fundamental techniques to handle complexity
-------abstraction
focus attention on only one aspect of the problem
and ignore other aspects and irrelevant details
--also called model building
--simplify a problem by omitting unnecessary details
---------------example
a map is an abstract representation of a country. various
types of maps(abstractions) possible. 
-----------------
every problem has more than one type of abstraction.
focus on specific aspect and ignore the rest.different type
of models help us understand different aspect of the problem.
for complex problems, a single level of abstraction is inadequate. a hierachy of abstractions may have to be construction.

hiehcrach of mdeosl:
----a model in one layer is an abstraction of the lower layer model

-------------------abstraction of complex formsD
asked to understand all life forms that inhabit the earth.

try to build an abstraction hierachy.

animal kingdom.

what is a model?

A model is an abstraction of a problem.

why develop a model? that is how does construction a model help?

we develop a model because of the cognitive limitation of the
human brain. 

give some examples of models.

A map or the animal kingdom are examples of models.


-------decomposition
-decompose a problem into many small independent parts
-the idea is that each small part would be easy to graph and
therefore can be easily solved.
-the idea is that each small part would be easy to graph and therefore can be easily solved.
-the full problem is solved when all parts are solved
-any arbitrary decomposition of a problem may not help
-the decomposed parts must be more or less independent
of each other

example use of decomposition principle

-you understand a book better when the contents are organized into independent chapters

------why study software engineering?
-to acquire skills to develop large programs
-handling exponential growth in complexity with size
-learn systematic techniques in software engineering
-to acquire skills to be a better programming
-----jobs vs project
-job repetition of very well-defined and well understood tasks with very little uncertainity
-exploration the outcome is very uncertain
-project in the middle! has challenges as well as routine

----types of software engineering products
--products(generic software)
--services(custom software)


1)Why is development time so long?
	-bugs
	-building the wrong thing (you didn't get the info right when figur=ing out what you should build)
		>Create a Spec document when you determine what it is you should build
	-process info = 1M to 1T Bits & ise it to control execution paths
	-Factor of 1,000 to 1B more complex than other kinds of engineering
		How to Fix? (best to use "agile development")
		- ***Simplify Execution Paths (Avoid Surprise)
			>example of exec path: "if-then-else"
			>controlled by the values in more than one variable
		- Reduce Complexity of Data flowing between "Boxes" (aka reduce # of interconnections)
			>at any given level when looking at your progam, you want that part to look simple
			>Box: a group of code that has a defined inteface connected to it
		- Reduce # of Data Paths
2)Why are development costs high?
	-hard to predict/estimate effort due to complexity (& unforeseen bugs)
	-labor intensive
	-* most effort is in find/fix RUNTIME bugs
	-*** Big percentage of projects fail
3)Why are there bugs in completed programs?
	-# of pathway combinations too big to test, ever. 
4)Why do we maintain existing (aka "Legacy") programs for so long? (aka "cash cows")
	-we don't want to spend the money to re-write since eventually they will lose their use
	-It works, so why bother
5)Why is it hard to measure development progress?
	-WBS helps a lot
		>Your list of tasks and subtasks
		>"Work Breakdown Structure"
	-"90-90" rule
		>80% overun
		>After 90% of the time(say you've built 90% of the software), you've acutally done only 50%, 
		 you have another 90% left (this is where you find most of the RT bugs
	-*** Most metrics[measurements] are poor & have (hidden) giant "error bar"
6)When is the development of a new type of program (New-Dev) easy and low risk?
	-use specialty-area "framework" (or "library") where your "PGM" is reduced to simple "biz logic"
		1. you write 10-15% of the total code
		2. framework is "preview"
		3. need your PBM to be VERY CLOSE to speciality-area
Ch 1.1.2 Application "Domains" (PBM areas)

8 Areas

1) System Programing
	-ex: OS, Network, RTime, Async, Distributed, Parallel
2) App
	-focused biz areas
2.5) "OR" Biz planning
	-"operations research" --> BIZ
3)Engineering/Science (w/ Numeric Accuracy)
4)Embedded
	-"IoT" (Robotics)
		>IoT = Internet of Things
5)"SPL" = S/W Product Line
	-Large core (the "framework") & small plug-in (Add-on) variations (features)
6)WEB/Mobile Apps (Games)
	-Sub-Apps Area
7)AI (robotics)
	-ML = machine learning
	-data mining
[8]Legacy
	-"Screen Scraping"

Chapter 2 -- Software Development Methodologies

"The [S/W] Process Framework"

5 "Phases" (may overlap)
     |  /0. Pre-Contract/
     |  1. Communication(what do you need to build)
     |  2. Planning(track the project)
     |  3. Modeling/Architecture Design
     |  4. Build(create program)
     |  5. Deploy/Ship(get program into user hands)

**Project Triangle --> For project "Feasibility" (Go/No-Go Decision)

BETTER	    /\ FASTER
Features/  /  \   Timeline/
Scope	  /    \    Deadline
   	 /______\
     	  CHEAPER
	 Effort/Cost

-1- Communication/ Requests(Arch)
	-customer = $$
	-user = plays with program
	-SME = Subject matter expert
-2- Planning
	-WBS
	-Task Dependencies
	->GANTT Chart
		>WBS as task per row
		-a spreadsheet
	-Assigned tasks to members

Chapter 2 (cont.)

5 Phases

Previous Lecture: (8/27)

1) Communication
2) Planning
___________________________

3) Modeling/Architecture Design
	-Sometimes called "Analysis" (OOA)
		> Object Oriented Analysis
	-User Scenario per Role
	-Use Case / Role + Task
	-CRC Card for every Agent
	-CRC Simulation: Card per Person

4) Build
	-Detailed Design of Medium-sized boxes
	-Unit Design
	-Unit Code
	-Unit Test
	-Small-scale integration
	-I&T (Big-scale) 
		>Integration & Test
	-V&V
		>Verification Test & Validation <-Users like it
		  ^Works per specs (requests)

5) Deploy/Ship
	-Package
	-Install Test
	-On-site "Acceptance" Test
	-Manuals
	-Training


Ch 2.2.2 "Admin" Tasks (aka "Umbrella")

>These are Not "Value-Added"
	-Do not directly result in working delivered program

Value-Added:
	1. Requests Spec
	2. Arch/Model/Analysis (OOA)
	3. Detailed Design and Coding
	4. Bug Fixing (NOT TEST)
	5. Integration, Package, Ship

Not Value-Added:
	1. Risk Management
	2. Project Tracking
	3. Tech Review
		-(code, design, ...)
	4. QA = "Quality Assurance"
		-Audit for good practices (policy, procedure)
		-Testers (newer)
	5. Measurements (aka "Metrics")
		-For prediction (aka estimation)***
		-Ex: LOC = "Lines of Code"
	 	     SLOC = "Sorce Linces of Code" [Adding a K in front means 1,000 Lines of Codes]
		     "Function Points" - very complicated
		     Cyclomatic Complexity [Count Loops]
		-Don't Forget Error Bars
	6. "Work Products" * Management 
		-Non-code documents
		-Ex: Customer Status Monthly
		     Preliminary Design Review Documents

--SKIP CHAPTER 3--

Chapter 4 Software Development MO's (aka Development "Process")

-modus operanddi:method of operation

-every program is developed according to a life cycle model

-emphasis has shifted from error correction to error prevention

-modern practice emphasize detection of errors as close 
to their point of introduction as possible

-modern practice coding is only a small part of the program development effort

-alot of effort is being paid to program specification

-periodic reviews are being carried out

-software testing has become systematic

-visibility means production of good quality, consistent and standard documentation

-in the past very little attention was being given to producing good quality and consisten documents

-project manager can accurately determine at what stage a project is on

-projects are being properly planned

------------------life cycle models-----------------------

-a life cycle is a set of stages to which a thing evolves

-software has a life cycle

-conceptualize->specify->design->code->test->deliver->maintain->retire
s
-A software life cycle model also process model or SLDC
-A descriptive and diagrammatic model of software life cycle
-Identifies all the activities undertaken during product development
-Establishes a precedence ordering among the different activities
-divide life cycles into phases

why model life cycle?

-a graphical and written description
--helps common understanding of activities among the software developers
--helps to develop inconsistencies, redundancies and omissions in the development process.
--helps in tailoring a process model for specific projects

-when a program is developed by a single programmer
--the problem is within the grasp of an individual
--when team development informal will create problem

-when software is being developed by a team
--there must be more systematic development

--A life cycle model
---defines entry and exit criteria for every phase.
---defines milestones to the project
----track the progress of the project
----phase entry and exit are important milestones
---the project manager can accuractely tell what stage the project is on
---99% complete syndrome

process models
----------------
waterfall
v model
evolutionary
prototyping
spiral models
agile models

------------
software life cycle is a series of identifiable stages that a software product undergoes during its life time:
	-feasibility study
	-requirements analsysis and specification
	-design
	-coding
	-testing
	-maintenance

classical waterfall model
--divides life cycle into following phases
--feasibility study
--requirements analysis and specification
--design
--coding and unit testing
--integration and system testing
--maintenance

stages are done sequentially.

simplest and most intuitive model

idealistic model

maintenance phase consumes maximum effort
tesing phase consumes the maximum effort among
development phases

--feasibility study
---use the project triangle

main aim of feasibility study is to determine
whether the software is finacially worthwhile
and technically feasible
-roughly understand what customer wants

---requirements analysis and specification
--understand the exact requirements of customers
--understand what the customer wants
--review requirement problems
--incosistencies
--anomalies
--incompleteness

--orgranize into a software requirements specification document

--gather relevant data
---usually collected from the end-users through interviews and discussion

----design
structures analysis
structured design

--high-level design
--decompose the system into modules
--represent invocation relationships among the modules

--detailed design
--oop design
identify the relationship among the objects
based on that we develop the design
--OOD has several advantages
---lower development effort
---lower development time
---better mantainability

coding and unit testing
--each modue of the design is coded
--each module is unit tested
--each module is documented

integration and system testnig
different modules are integrated in a planned moanner
--modlues are integrated through a number of steps
--during each itnegration step the partial integrated system is tested.
--test if they are interface bugs

--system testing
---the whole system is checked to see if it meets the requirements that have been expressed in the documents

--maintenance of any software
---requires much more effort than the effort to develop the product itself

iterative waterfall model

assumes that no defect is introduced during any development activity

the later the phase in which the defect gets detected, the more expensive is its removal

in practice defects do get introduced in almost every phase of the life cycle.

errors should be detected in the same phase

waterfall strengths
--easy to understand, easy to use
--milestones are well understood by the team
waterfall cons
--all requirements must be known upfront, in most project requirements change occurs after project start
--integration is one big bang at the end
--little opportunity for customer to preview the system

iterative waterfall model

provides feedback
way to go back and fix problems in stages.

V model
-variant of the waterfall model
-emphaszes verification and validation
-v&v activities are spread over the entire life cycle

pros
emphasez for veriication and validation of the software
easy to use

prototyping model

very similar to waterfall model
before starting actual development
a working prototype of the system should be built

a prototype is a toy implementation of a system

limited functional capabilities
low reliability
inefficient performance

reasons for prototyping 

learning by doing:useful when requirements are only
partially known

-improved communication
-improved user involvement
-reducedd need for documentation
-reduced maintenance costs

reason for developing a prototype
-illustrate to the customer
-developers can examine technical issues

cons
does not support overlapping of phases
requirements still need to be know upfront
does not handle iterations or phases
does not easily accommodate later changes to requirements

Learning by doing: useful where requirements are only partially known

improved communication

improved user involvement

reduced need for documentation

reduced maintenance costs

impossible to get it right the first time

we must plan to throw away the first version

start with approximate requirements

carryout a quick design

the developed prototype is submitted to the customer for his evaluation.

design and code for the prototype is usually thrown away.
prototype helps the development of the software

1. difficulty in accomodating change requests during development

2. high cost incurred in developing custom applications

3. heavy weight processes. lots of documentation is produced

huge mountain of documentation.
nearly half the time the developers are documenting. docuemntation does not produce real software

-requirements are assumed to be fixed from that point on.
-long term planning is made based on this.
-key characterisics

incremental development

initial requirements split into feature
iterative has many releases
first increment: core
second increment: add/fix
final: complete product

each iteration is a short project

which step first?

some steps will be pre-requisite because of physical dependencies

others may be in any order

value to cost ratios may be used

----------------evolutionary model-------
"plan a little, design a little, and code a little"

-encourages all development participants to involved early on.
advantage of the evolutionary model is that you get feedback
early on about what the customer wants and doesn't want.

-first develop the core modules of the software

-software developed over several waterfallls

-evolutionary model with iteration

---outcome of each iteration test,integrated, executable system
---iteration length is short and fixed
---successive versions
-----functioning system capable of performing some useful feature
-----evolves an initial implementation with user feedback
-----multiple version until final version 

pros
-user get a change to experiment with a partially developed system
-help find exact user requirements
-software more liekly to meet exact user requirements
--better management of complexit by developing one increment at time
-can get customer feedback and incorporate them much more effeciently
-frequent releases allow developers to fix unanticipated problems quicker
-the process is intangible
    -no regular, well-defined deliverables
-the process is unpredictable
    -hard to manage
-systems are rather poorly structured
    -continual, unpredictable changes tend to degrade the software structure

-unified process
---developed ivar jacobson, Grady Booch and James Rumbaugh
----Incremental and iterative

 __________________________________
| Knobs == Parameter to "tune"     |
| Tune Wrong -> Bad Estimate       |
| J. Von Neumann                   |
|__________________________________| <-- Quote

(0) Anarchy = (absence of) No visible method

1) Phases + Gates
	-Big Project Issue: Request Changes
	-Requests <-> Architecture <-> Design & Code <-> ... <-> Ship -> Users get to try it [Waterfall diagram]
	-Big Con: Length of user feedback loop***
	-Q: Users like it? -> Validation

Chapter 4 cont

Previous Lecture (9/1)

0. Anarchy
1. Phases + Gates
____________________________________

2. Spiral "Model" (-Barry Boehm)

	_________________
       | custom == $$    |
       | user == use pgm |
       |_________________|

	Spiral == waterfalls
	-You can check with user 

 Pack/Ship  RQT    ARCH
       \     |     /
  -->___\____|____/___
      ___\___|__ /   |
      |	  \  |  /    |
      |	|  \ | /|    |
      | |__/_|_\|    |
      |___/__|__\____|
         /   |   \
        /    |    \
     I&T    UNIT    DETAILED
	   CODE &     DESIGN
	    TEST

3. V-Model (cute, but obselete)

	REQTS\.............../Verify
	  ARCH\............./I&T
       Detailed\.........../Small Scale
	  Design\........./  Integration
	Unit Code\......./Unit Test
                  \_____/

4. Evolutionary
			   __________________________________________
	-Like spiral, but |Test Each Working Feature Slice with users|
			  |__________________________________________|


[5. Concurrent]	
	-split teams at multiple geographic sites

[6. Component-Based]
	-use COTS
		> "Commercial (or common) Off-The-Sheld" S/W

	-usually:
		1. 3rd party LIB
			> you call fcns
		2. Frameworks
			> you inherit & add method overrides
 	_________________________________________
       | RFP = "Request For Proposal"            |
       |   -Tell them what would work & extra    |
       |     things/features needed              |
       | RFQ = "Request For Quotes"              |
       |   - $$ for the PROPOSED task            |
       |_________________________________________|

7. Agile
	-2001 manifesto(12 pts/items)
	-4 motivations = Avoid:
		> Death Marches [168 hrs/week]
		> User Surprises
		> Overly-Rigid Design
		> Gold-Plating
			- We're gonna need it
			- For later REUSE
			- I think this is MAYBE required
8. The "Unified" Process (Model)(in Section 4.3)
	-UML = Unifies Modeling Language
		>Automated Tool Help ("Rational")
	-Created by the "Triplets" (Booch, Rumbaugh, Jacobson)
		>Merged Models 
		>OMG = Object Management Group
	-4 keys:
		1. Driven-by Use-Case
		2. Arch-Centric
		3. Iterative (Feature Set Slices)
		4. Incremental (Best Slices First)
			> *Show Users	

Previous Lecture (9/3)

Chapter 4
____________________________

Chapter 5 Agile (2001)

4 motivations - Refer to 9/3 Notes under 7. Agile

4 preferred values
	1. (II > PT)
		-Individuals & Interactions over (>) Processes [aka models] & Tools [e.g. UML]
	2. (WS > CD)
		-Working Software over Completed Documents
	3. (CC > CN)
		-Customer Collaboration over Contract Negotiation	
	4. (FC > FP)
		-Flexible to Change over Follow the Plan

Manifesto - has 12 items
-->Better Half<-- [the items in the manifesto he's showing/teaching us]
	1. Satisfy the CUSTOMER through early & continuous(often) deliveries
	2. Accept changing requirements at all times
	3. Deliver Evolving products every 2 to 8 weeks
	7. Measure progress in working software features
	10. Simplicity is better than quantity, in code (no LOC/SLOC measurement)
	11. ::skull and crossbones:: Let the team self-organize [no leader]
		> Most companies who say they do agile, do not do this

Side Note: "Scrum" := agile with Time Boxs

Agile Stand-up Meetings
	-Start of the Day
	-Stand at the "Progress Board"
		...Features..|Ready|WIP|QA|Done
		   "Work In Progress"^   ^"Quality Assurance"
	-15 minutes (or less)
	-Everyone answers 3 questions
		Q1. What was completed yesterday?
		Q2. What do you plan to complete today?
		Q3. Any obstacles?
			> Do due diligence
_______________________________________________________________________________________

More Chapter 4

Chapter 4.1.3 "Prototyping"

2 Kinds:
	1. Special Tech
		> Quick, Rough Proof-of-Concept
		> AKA Check that new tech works
		> Ex:
			-new algorithm
			-API, new library
			-new framework to get used to
			-connect to remote box -- protocol
		> ***Not to show to users
	2. NFS-0 (version 0)
		> Minimum Feature Set
		> To show working stuff
		> Black box (no user "drive")
		> 1st cut of "sweetest" requests
			-(pry/effort)
		> *Main scenario

Previous Lecture (9/8)

2 Kinds of Prototyping
____________________________

Chapter 4 Process Models (aka SW Development Models)

5 Phases:
	-Comm, Plan, Model, Build, Ship
How to Begin?
	-Communication->UC->Model "Pipeline"
		>For quality requirements
			-aka "Non-Functional" OR "Ilities"
						   ^ex: Durabilities
		>To create requirements
	-User-Communication
		>not exact details
Determine Usage (How Used)
	-USCENS = "User Scenarios" and EIO's (v0)
		>EIO= Example Input Output
	-Extract UCs = "Use Cases" and Pry 'em
		>user's priority
		>Work in PRY order!
	-Sketch UC Steps (aka Main Scen) & EIO's (v1)
	-Extract Agents (maybe shared by other UCs) & Major Data
		>Stuff user understands
		>CRUD ops
			-Create
			-Read
			-Update
			-Delete
		>Send/Recieve messages
	-Note UC extras + EIOs (v2)
		>kinds of "extended scenarios"
			-Error Handling
			-Frills
			-Variations from STD processing
			-...
	-Extract Quality Requirements + Pry 'em
		>Especially:
			-Performance?
			-Distributed?
			-H/W Hosts
			  ^Hardware
			-Legacy "Fit"
			  ^Ancient Stuff
	-Sketch 1st UCs "Model" (CRC Architecture)
	-Eval Model (CRC Sim)
	______Add it all together_____________
		-Model Sketch
		-UC Processing Steps
		-Some problem domain understanding
		-Some user agreement feedback
	______________________________________
	-USCEN's
		>2+ Rambling Paragraphs
			-{Ch 8.2, 8.3.3, 15.4.1}
		>1 user role (actor)
		>In user "domain" language
			    ^aka user problem domain language
		>What does PA need to do?
			    ^Personal Assitant
	-Big Pile of Text (from talking with users)
		>focus on ACTS & results
		>what Acts in what order ?
		>what Pry's? (small,med,large)

Chapter 8.2.3: UC's

6 parts: (1 Task + 1 Role) [parts of a Use-Case]

#3. Summary Paragraph
	>Cut and paste from USCEN
#2. One sentence, one verb (SRP [Single Responsibilty Principle])
	>SOLID/D principles (where SRP is the S in Solid)
#1. Title (verb + object)
#4. User role
#5. Agents & Major data
#6. Main Scenenario (3-8 steps)

Previous Lecture (9/10)

6 parts of the Use-Case
____________________________

Chapter 5 Human Aspects

I. Personal and II. Social
	-"Be Effective"
	-You,yourself
		-your "word"
			-protect it by using "I PLAN to do x"
			-tell the TRUTH
			-Be polite & tactful
			*Avoid raw(harsh) brutal honesty
	-Keep the "Team"
		-Group that helps each other
		-Be "neighborly"
		-help others
		-be polite
		-"heads-up" Truthfulness (but tact)
		**Ask a question, Don't make a statement
		*Egos are always involved

^^^^^^^^^^^^^^^^^^^^^^NOT ON AN EXAM^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	-You must "sell" your ideas
		1. Ask a question, Don't make a statement
		2. Use "issue" or "question" not "problem" 
		3. Keep goals in mind
			-Review(in your head) how important it is
		4. Find Standards that give your viewpoint
	****Show more-than-fairness
		-Always give more than what you get
		-kindness & generosity & overdo it
		-cut others more slack than you think you get
		*Don't give adivce, just answer questions (or ask some)
		***Don't "Bad-Mouth" others
			-Always have something good to say
		*Show an interest in other's ideas
	-Be open to possible change. (officially)
		-"I'm not sure I understand"
			-"ATMOR"  <--used in the HR deapartment/what manager does
				-Attract
				-Train/Develop
				-Motivate
				-Organize
				-Retain
	-Attention to Detail
		-Always test your code before "hand-off"
	***Always come up with a way to test (EIO)
III. Development
	-Learn new stuff every waking moment, if you can
	-basic mechanisms over latest tools
	-Fred Brooks - Mythical Man-Month
		("No Silver Bullet")
		1. Coggins: Best of C++
			- PBM: Strong Type-Checking
			- gets in way of big PGMs
		2. David Parnas
			- OOP as design, not a LANGUAGE


Effort
|
|    |_________|
|    |         |\			"Dinosaur Diagram"
| | /|         | \
| |/ |  Build  |  \__|_____
| |  |         |     |
|/|__|_________|_____|_________Time
   ^Solve the    ^Debug & Test
     problem

		3. Reuse: Capers Jones
			- All business that have >5K PGMRS have REUSE GROUP
			- <10% of groups under 500 PGMRS have REUSE group
		4. Parnas:
			- no reuse BECAUSE bad design and/or bad docs
		5. Ken Brooks
			- 5th version,still don't understand how to generalize it
			- apropos of SPL's
		6. C. Jones
			- There exists few reuseable code modules for sale


Previous Lecture (9/15)

Personal, Social, and Development
____________________________

Chapter 5 continued

****Always give them a 2nd chance  <-- NOT ON EXAM


- 5 Toxic Team Posions ~ pg 77  [Jackman 1998]
	1. Death March
		- "Frenzied Work Atmosphere"
	2. High Frustration causes friction
		- Avoid bad comments
	3. Poorly coordinated software process(M.O.) 
						^ Modus operandi
		- Phases & Tasks MIA
	4. Unclear Roles
		- Who does what?
	5. Continuous repeated [micro-]failures
- Strong Teams [Cockburn & Highsmith (2001)]
	1. People > Process (M.O.)
	2. Politics > People

Modeling/Arch/Analysis                     
Chapter 8.3.4 Cards                                                                  _____________
	- Data/Reqts in UCs                                                             |      B      |
		- Class (/Agent/Object)                                                 |_____________|
		- Responsibility (agent Actions)                                        |      |      |
		- Collaborators (other agents, helpers)                                 |______|______|
	- 3x5 cards                                                                            ↑
	  _____________________________________                                                |                              
         |            CLASS TITLE              |           		    ___________        |     _________
         |_____________________________________|           		   |     A     |  -----┘    |    C    |
 Action  | Responsibilties   | Collaborators   |        		   |___________|            |_________|
>methods |   ....            |    ....         |          		   |     |     | --------→  |    |    |
         |   ....            |    ....    -----|---Collab = link---------→ |_____|_____| ←--------  |____|____|
         |___________________|_________________| 
	
	- CRC Graph == Static Arch  (example above)
	- Hand-Simulation Use-Case Flow on Graph == Dynamic Arch
	- All names/phases in User Language
	- 3 Kinds of CRC Classes/Agents
		- Entity
			> Long-lived Agents
		- Controller
			> MGRs others
			  ^manages
		- Boundary
			> Talks to outsiders


Previous Lecture (9/17)
 
CRC Cards
____________________________

Chapter 8.5.2 UML FSM's
		   ^Finite State Machine (DFA, Determinitstic Finite Automaton)

	-State Transition Table
									
	State |   Inputs/Events                                
	       __A__|__B__|__C__| 		       
   S.S.-> 1   |  3  |  1  |  2  |			
Start^    2   |  4  |  -  |  -  |			
State     3   |  -  |  1  |  2  |  			
         (4)  |  3  |  2  |  -  |   		
          ^Acceptor

	-State Transition Diagram (or Graph)

                 /"Call Fred"; Action     		
       ┌B-┐       ↓
 S.S.> └→(1)------A-----→(3)
	  | ←----B------  ↑
	  C   ____C____/  A
	  ↓ ←/            |
	 (2)------A-----→((4))<Acceptor [often indicated by a double ring]
	  ↑-----B---------┘			 

	-UML Sequence "Pole" Diagram (for protocols)	[Agent On Poles]

	Alice		Bob		Eve			Time
          |		 |		 |		          ↓
	  + ------#1--->[] 		 |			  +
          | <--ACK #1---[]------#2----->[]			  +
          |		 |              []
  	  |		[] <----Q#3-----[]
	  |  		[]		 |
 	  |		[]-------A#4--->[]
	 []<-------------|--------------[]  
	  |		 |		 |

	-UML Class Hierarchy
	
		Object						______________
 ┌-------------→   ↑					       |      A       |
 |		   A	←--What each box will look like--      |______________|
The arrow should   |					       | -details...  |    
not touch the box→ ↑_______				       |______________|
		   |	   |			
		   B	   C
		   ↑	   ↑
		   |	   |	
		   E	   D

	-UML Class/Object Associations
		
			| B | --------> | C |
				↑"Uses"/"Calls"
			| B |-----o)---| C |  ( ←Alternative notation)


Example of CRC Cards for Project Part 1

Parts CRCs Example
	o- Input: The UCs built earlier
		UC: VCS - Create Repository
		2. Create  a new repo in a folder for a project tree of folders/files
		3. Summary: see pdf assignment
		4. Role: VCS User
		6. Main-Scen:
			o- Get source & target
			o- Start new mainfest file with cmd-line & timestamp
			o- Traverse source tree: for each file: {
				o- Create file's Art-ID ("CPL"<-- In image of cards on BB)
				o- Add file line to Manifest
				o- Copy file into repo w/ Art ID filename }
		5. Agents (Mgrs/Handlers): Repo, Manifest, File, PLC-ID, Treewalker, VCS User
	Key: Try to limit couplings in the architecture graph
	Note: How UC(s) mismatches Parts CRCs, also note awkwardness in picking Agents & placing reponsibilities
		(Cards are cheap. Try ideas)
	Q: Who should be boss of (or collab with) who?

[See post on BB for images of example cards]

GOF Design Patterns, 1995


  ___________            ____________________			
 |  CLI      |          | [I] Helper         |		       
 | -IHref [] | -------→ | -no slots          |  	       
 |___________|          | -no MD Bodies      |  <-MD: method               
        |               |____________________|		       
	|			|
	|			|
	|			↑
	|        		|
        |                _______|____________			______________
        |               | Helper-A           |		       | [I] OddBall
 	|               | -IOref []          |---------------→ |
        |               |                    |                 |_______________|
        |               |____________________|		              |
	|			|				      ↑
	|			|				      |
	|			|				______|_________
CTOR -->|			|			       |  OddBall-A     |
        |			|			       |________________|
	|			|					|
	|			|					|
      __|______		    ____|____				    ____|____
     (CLI #21  )	   ( HLP #61 )				   (ODDB #57 )
     ( IHref [])---------->( IOREF [])---------------------------> (_________)
     (_________)	   (_________)	
				
Basic Cutout:
  ___________            ____________________			
 |  CLI      |          | [I] Helper         |		       
 |  -HREF [] | -------→ | -DoIt              |  	       
 |___________|          |                    |                 
          ↑             |____________________|		       
        little                   |
        box in                   |
         CLI                     |
        |                        |
	|		        _|
	|		       |
	|		       |
	|		       |
  ______|__                    |
 ( CLI (A) )             ______|_____
 ( Ref[]   ) ----------→( Helper (B) )
 (_________)		(____________)	


Previous Lecture (9/22)

UML FSM's
____________________________

Exam Review

-------
What email of exam answer looks like:

Subject: 343-01 Q5
Email Body: C 

------

Know the Acronyms!!!
Anything on notes is fair game from 8_27 to 9_22 
Open Book, Open Note
Majority will be Multiple Choice

Project Triangle: use secondary words --> Features/Scope[NOT Better], Timeline/Deadline[NOT Faster], Effort/Cost[NOT Cheaper]
LOC - just need to know that it stands for Lines of Code (similarly for SLOC)
3rd Party Library is NOT a Framework
*4 Preferred Values (don't need to know acronyms specifically) [this is II>PT, WS>CD, CC>CN, & FC>FP]* <-- 9_8
Memorize what CRUD(CREATE READ UPDATE DELETE) stand for
Know how CRC cards are set up

Not on Exam:
	-SME(Subject Matter Expert)
	-Function Points
	-Cyclomatic Complexity
	-quote from J. Von Neumann [knobs and tuning](why things go wrong)
	-how a framework works
	-the date of agile manifesto [2001]
	-168 hrs/week from death march - Know what death march is though
	-the Triplets: merged models 
	-OMG(Object Management Group)
	-"Progress Board" -- from agile standup reports section
	-None of I. Personal and II. Social from lecture 9_15 [Except for ATMOR]
	-No Fred Brooks
	-Also No III. Development (also from 9_15)
	-No dates in general
	-UML State Transtition TABLE
	-SOLID/D

CECS 343 Acronyms 
IoT = Internet of Things
"SPL" = S/W Product Line
ML = machine learning
WBS = Work Breakdown Structure
SME = Subject matter expert
OOA = Object Oriented Analysis
I&T = Integration & Test
V&V = Verification Test & Validation
LOC = "Lines of Code"
SLOC = "Sorce Linces of Code" 
QA = "Quality Assurance"
COTS = "Commercial (or common) Off-The-Sheld" S/W
RFP = "Request For Proposal"
RFQ = "Request For Quotes"
UML = Unified Modeling Language
II = Individuals & Interactions
OMG = Object Management Group
PT = Processes & Tools
WS = Working Software
CD = Completed Documents
CC = Customer Collaboration
CN = Contract Negotiation	
FC = Flexible to Change
FP = Follow the Plan
WIP = "Work In Progress"
EIO= Example Input Output
USCENS = "User Scenarios"
UCs = "Use Cases"
CRUD = Create, Read, Update, Delete
H/W = Hardware
PA = Personal Assistant
SRP = Single Responsibilty Principle
ATMOR = Attract, Train/Develop, Motivate, Organize, Retain
M.O. = Modus operandi
MGRs = manages
FSM = Finite State Machine
DFA = Determinitstic Finite Automaton
CRC = Class, Responsibilities, Collaborators
MFS = Minimum Feature Set
COTS = Commercial(Common) Off-The-Shelf
MD = method
